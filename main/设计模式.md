### 适配器设计模式

#### **1. 适配器概述**

> 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。——《设计模式：可复用面向对象软件的基础》

适配器模式是一种对象结构型模式。

这里的接口不仅仅是java语言中的interface，更多是指一个类型所具有的方法特征集合，是一种逻辑上的抽象。

#### **2. 角色**

- 目标角色（target）：这是客户锁期待的接口。目标可以是具体的或抽象的类，也可以是接口

- 适配者角色（adaptee）：已有接口，但是和客户器期待的接口不兼容。

- 适配器角色（adapter）：将已有接口转换成目标接口。

#### **3. 适配器模式分类**

- 1、类适配器模式（class adapter pattern）
- 2、对象适配器模式（object adapter pattern）
- 3、缺省适配器模式（default adapter pattern），也叫默认适配器模式、接口适配器模式

#### **4. 类适配器模式（class adapter pattern）**

***类适配器模式在编译时实现target（目标）。***此种方式是针对目标角色(Target)是真正意义上的接口，通过建立适配器类实现目标接口，继承适配者类，然后实现目标接口中的方法，通过调用适配者类中的方法来实现。最后将适配器提供给用户使用。

图示：

1. 类适配器模式的结构图：

   <img src="..\pic\design\adapter\class-adapter.jpg" alt="类适配器结构图" style="zoom:67%;" />

2. 类适配器模式的具体实现图：

   <img src="..\pic\design\adapter\class-adapter-detail.png" alt="类适配器模式实现原理图" style="zoom:67%;" />



#### **5. 对象适配器模式（object adapter pattern）**

***对象适配器模式在运行时实现target（目标）接口。***在这种适配器模式中，适配器包装了一个类实例。在这种情况下，适配器调用包装对象实例的方法。（此时适配者类可以为类、接口、抽象类）

图示：

1. 对象适配器模式的结构图：

   <img src="..\pic\design\adapter\object-adapter.jpg" alt="对象适配器结构图" style="zoom:67%;" />

2. ##### 对象适配器模式的实现原理图

   <img src="..\pic\design\adapter\object-adapter-detail.png" alt="对象适配器实现原理图" style="zoom:67%;" />

#### **6. 类适配模式 和 对象适配模式的对比**

优点：

- 类适配器模式（class adapter pattern）：

  由于适配器adapter类是适配者adaptee类的子类，因此可以在适配器类中置换一些适配者的方法，即Override（重写），使得适配器的灵活性更强。

- 对象适配器模式（object adapter pattern）：

  一个对象适配器可以把多个不同的适配者adaptee适配到一个目标，也就是说，同一个适配器可以将适配者类和它的子类都适配到目标接口。

缺点：

1. 类适配器模式：

* java8之前：接口没有default方法，就是没有实现了具体逻辑的方法，而且不支持类多继承，所以**适配者类只能有一个**。

- java8之后：接口有了default方法，接口中的方法有了实现，因为接口是多继承的，所以适配者可以是多个带有default方法的接口；（但是接口是不可以实例化的，实际上没有什么意义。有个解决方法就是，接口里都是default方法，实现接口的类什么也没做，就是提供一个可以实例化的类。这样的化，类适配器模式中适配者adapter类就可以适配多个适配者adaptee类了。这个解决方法只是我理论上论证一下，实际上可行与否，请自行判断验证）。

2. 对象适配器模式：

   类适配器模式的优点就是对象适配器模式的缺点，不能置换适配者类的方法。如果想修改适配者类的一个或多个方法，就只好先创建一个继承与适配者类的子类，把适配者类的方法置换掉，然后把适配者的子类当做真正的适配者进行适配，实现过程较为复杂。

#### **7. 默认适配器模式（default addpter pattern）**

使用背景：当目标对象想实现某个接口中的部分方法时，由于实现该接口需要实现接口中的所有方法，因此和实际的需要不一致，此时就可以使用默认适配器模式

默认适配器模式就是指创建一个适配器抽象类对某个接口进行**空实现**，目标对象继承抽象类选择需要的方法进行实现；

备注：java8之后就不需要这种模式了，因为java8后接口支持default默认方法了；



### 工厂设计模式

1. #### 简单工厂设计

   创建一个工厂类，根据传的不同的类型，创建不同的类并返回。

<img src="C:/Users/99726/Desktop/study-notes/pic/Interview/SimpleFactory.png" alt="简单工厂" style="zoom:50%;" />

2. #### 工厂方法设计

   创建一个抽象工厂类，不同对象的工厂类继承抽象类，利用多态创建不同的对象。

   如图：

<img src="C:/Users/99726/Desktop/study-notes/pic/Interview/FactoryMethod.jpg" alt="工厂方法" style="zoom:50%;" />

3. #### 抽象工厂设计

   定义抽象类，定义不同的方法，不同对象的工厂类继承抽象类，利用多态创建不同的对象

<img src="C:/Users/99726/Desktop/study-notes/pic/Interview/AbstractFactory.png" alt="抽象工厂" style="zoom:50%;" />



